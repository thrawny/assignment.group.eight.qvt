modeltype Workflow uses workflowengine('http://workflowengine/1.0');
modeltype Petrinet uses petrinet('chalmers.se/cse/mde2014');

transformation Workflow2Petrinet(in sourceW:Workflow, out targetT:Petrinet);


main() {
	var globalNet := sourceW.rootObjects()[Workflow::Case]->map case2petriNet();
}

mapping Workflow::Case::case2petriNet() : PetriNet {
	result.name := "GlobalNet";
	
	/*
	*
	*Step 1: mapping startPoint, endPoint and tasks to places
	*
	*/
	result.nodes := self.contains_tasks.map task2place(result)->asOrderedSet()
		->union(self.begins_with.map sp2place(result) -> asOrderedSet())
		->union(self.ends_with.map ep2place(result) -> asOrderedSet());
		
	/*
	*
	*Step 2: mapping controllers to transitions
	*
	*/
	result.nodes := result.nodes->union(self.contains_controllers.map controller2tran(result)->asOrderedSet());
	
	
	/*
	*
	*Step 3: check for special cases in our model and transform them accordingly in petrinet
	*
	*/
	
	//Creating a writable copy of the transitions
	var transitions := self.contains_transitions;
	
	//Creating a writable copy of nodes
	var places := result.nodes;
	
	//Temporary collection for entities that are not controllers
	var tmp : Set(Element);
	
	//Searching for special cases on tasks
	tmp := tmp->union(self.allSubobjectsOfType(StartPoint))
		->union(self.allSubobjectsOfType(Task))
		->union(self.allSubobjectsOfType(EndPoint));
		
	tmp -> forEach(tmp1){
	tmp -> forEach(tmp2){
		//Casting
		var task1 := tmp1.oclAsType(Workflow::Entity);
		var task2 := tmp2.oclAsType(Workflow::Entity);
		
		if(task1 <> task2 ) then {
			//Creating the intersection of transitions
			var commonTrans := task1.outgoing_transitions->intersection(task2.incoming_transitions)->asOrderedSet();
			
			//There's a connection
			if (commonTrans->size() = 1) then{
			
			//Creating the dummy transition between the two places 
			var transition : Petrinet::Transition := new Petrinet::Transition();
			
			//Creating the two places
			var place1 := places[name = task1.entity_id]->first();
			var place2 := places[name = task2.entity_id]->first();
			
			//Creating the connecting Arcs
			var arc1 : Petrinet::Arc := new Petrinet::Arc();
			var arc2 : Petrinet::Arc := new Petrinet::Arc();
			
			//Populating arcs' properties'
			arc1.source := place1;
			arc1.target := transition;
			arc1.net := result;
			arc2.source := transition;
			arc2.target := place2;task1.outgoing_transitions->intersection(task2.incoming_transitions);
			arc2.net := result;
			
			//Populating the transition properties
			transition.name := task1.entity_id+" to "+task2.entity_id;
			transition.net := result;
			transition.incoming := arc1->asSet();
			transition.outgoing := arc2->asSet();
			
			//Removing the transition already transofrmed
			transitions := (transitions- commonTrans)->asOrderedSet();
			
			//Adding the transition to the petrinet
			result.nodes += transition;
			
			//Adding the arcs to the petrinet
			result.arcs += arc1;
			result.arcs += arc2;
			
			//Addng incoming and outgoing arcs to the places
			place1.outgoing := place1.outgoing->union(arc1->asSet());
			place2.incoming := place2.incoming->union(arc2->asSet());

		}endif
		}endif
	}
	};
	
	


	
	
	//Searching for special cases on controllers
	self.contains_controllers -> forEach(cont1){
	self.contains_controllers -> forEach(cont2){
		
		if(cont1 <> cont2) then{
			//Creating the common transitions
			var commonTransitions := cont1.outgoing_transitions->intersection(cont2.incoming_transitions);
			
			//There's a match'
			if(commonTransitions->size() <> 0) then {
			
				//Creating a dummy place between the two controllers
				var place : Petrinet::Place := new Petrinet::Place();
				
				//Creating the arcs to connect them
				var arc1 : Petrinet::Arc := new Petrinet::Arc();
				var arc2 : Petrinet::Arc := new Petrinet::Arc();
				
				//Creating the two transitions
				var tran1 := nodes[name = cont1.entity_id]->first();
				var tran2 := nodes[name = cont2.entity_id]->first();
				
				//Populating the transitions properties
				arc1.source := tran1;
				arc1.target := place;
				arc1.net := result;
				arc2.source := place;
				arc2.target := tran2;
				arc2.net := result;
				
				//Populating the dummy place properties
				place.name := cont1.entity_id+" to "+cont2.entity_id;
				place.net := result;
				place.incoming := arc1->asSet();
				place.outgoing := arc2->asSet();
				
				//Adding the dummyplace to the petrinet
				result.nodes += place;
				
				//Adding the arcs to the petrinet
				result.arcs += arc1;
				result.arcs += arc2;
				
				//Removing the transition already transofrmed
				transitions := (transitions- commonTransitions)->asOrderedSet();
				
				//Addng incoming and outgoing arcs to the places
				tran1.outgoing := tran1.outgoing->union(arc1->asSet());
				tran2.incoming := tran2.incoming->union(arc2->asSet());
				
				
			} endif;
		}endif
	}
	};	
	
	/**
	*
	* Step 4: Adding the remaining arcs
	*
	*/	
	result.arcs := result.arcs->union(transitions.map tran2arc(result, self)->asOrderedSet());
		
	
	
	/**
	*
	* Step 5: Creating resources
	*
	*/
	self.contains_tasks -> forEach(task){
		task.is_associated_to -> forEach(resource){
			
			//Creating a place for storing the resource
			var place : Petrinet::Place;
			if(result.nodes[name = "Resource "+resource.resource_id]->size() = 0) then{
				place := new Place();
				place.tokens := new Token()->asOrderedSet();
			}
			else {
				place := result.nodes[name = "Resource "+resource.resource_id]->oclAsType(Place)->first();
			}
			endif;
			
			
			//Creating  dummiTransition
			var dummiTran := new Petrinet::Transition();
			var dummiPlace := new Petrinet::Place();
			dummiTran.name := "Dummi tran for resource "+resource.resource_id;
			dummiPlace.name := "Dummi place for resource "+resource.resource_id;
			
			dummiTran.net;
			dummiPlace.net;
		
			//Getting the place associated with the task that contains this resource
			var resourceOwner := result.nodes[name = task.entity_id]->first();
			
			//Getting the next transition after the task
			var nextTransition := result.nodes[incoming->intersection(resourceOwner.outgoing)->size() <> 0]->first();
			
			//Creating the arcs
			var arc1 := new Arc(result, place, dummiTran);
			var arc2 := new Arc(result, dummiTran, place);
			var arcToDummiTran := new Arc(result, resourceOwner, dummiTran);
			var arcToDummiPlace := new Arc(result, dummiTran, dummiPlace);
			var arcToNextTran := new Arc(result, dummiPlace, nextTransition);
			
			
			place.outgoing := place.outgoing ->union(arc1->asSet());
			place.incoming := place.incoming ->union(arc2->asSet());
			
			nextTransition.incoming := place.incoming->union(arcToNextTran->asSet());


			var existingArc := result.arcs[source = resourceOwner and target = nextTransition]->asOrderedSet()->first();
			resourceOwner.outgoing := resourceOwner.outgoing->excluding(existingArc);		
			nextTransition.incoming := nextTransition.incoming->excluding(existingArc);
			result.arcs := result.arcs->excluding(existingArc);
			
			resourceOwner.outgoing := resourceOwner.outgoing->union(arcToDummiTran->asSet());
			
			
			dummiTran.incoming += arcToDummiTran;
			dummiTran.outgoing += arcToDummiPlace;
			
			dummiPlace.incoming += arcToDummiPlace;
			dummiPlace.outgoing += arcToNextTran;

			
			

			result.arcs += arc1;
			result.arcs += arc2;
			result.arcs += arcToDummiTran;
			result.arcs += arcToDummiPlace;
			result.arcs += arcToNextTran;

			
			
			//populating the resource place
			place.name := "Resource "+resource.resource_id;
			
			//adding the place generated to the collection
			result.nodes := result.nodes->union(place->asSet());
			result.nodes := result.nodes->union(dummiTran->asSet());
			result.nodes := result.nodes->union(dummiPlace->asSet());
		}
	};
	

}

mapping Task::task2place(in globalNet : PetriNet) : Petrinet::Place {
	result.name := self.entity_id;
	result.net := globalNet;
}

mapping StartPoint::sp2place(in globalNet : PetriNet) : Petrinet::Place {
	result.name := self.entity_id;
	result.net := globalNet;	
	result.tokens := (new Token())->asOrderedSet();
}

mapping EndPoint::ep2place(in globalNet : PetriNet) : Petrinet::Place {
	result.name := self.entity_id;
	result.net := globalNet;
}

mapping Controller:: controller2tran(in globalNet : PetriNet) : Petrinet::Transition {
	result.name := self.entity_id;
	result.net := globalNet;
	if self.oclIsKindOf(Selection) 	then {
		result.transition_type := petrinet::Type::Selection;
	} else if self.oclIsKindOf(Synchronization) then {
		result.transition_type := petrinet::Type::Synchronization;
	} else if self.oclIsKindOf(FIFO)  then {
		result.transition_type := petrinet::Type::FIFO;
	} else if self.oclIsKindOf(Iteration) then {
		result.transition_type := petrinet::Type::Iteration;
	} else {
		result.transition_type := petrinet::Type::Fork;
	}
	endif endif endif endif;
}

mapping Workflow::Transition::tran2arc(globalNet: PetriNet, ourCase : Case) : Petrinet::Arc {
	//Casting
	var entities := ourCase.allSubobjectsOfKind(Entity)->oclAsType(Entity);
	
	//Getting source and target nodes
	var sourceNode := globalNet.nodes[name = entities[outgoing_transitions->includes(self)]->asOrderedSet()->first().entity_id]->asOrderedSet()->first();
	var targetNode := globalNet.nodes[name = entities[incoming_transitions->includes(self)]->asOrderedSet()->first().entity_id]->asOrderedSet()->first();
	
	//Populating the properties of the arc
	result.net := globalNet;
	result.source := sourceNode;
	result.target := targetNode;
	
	//Adding the arc as outgoing and incoming for sourceNode and targetNode respectively
	sourceNode.outgoing := sourceNode.outgoing->union(result->asSet());
	targetNode.incoming := targetNode.incoming->union(result->asSet());
	

}

mapping Resource::res2Place( net: PetriNet, workflow: Case): Petrinet::Place {
	//Getting the place associated with the task that contains this resource
	var resourceOwner := net.nodes[name = workflow.contains_tasks[is_associated_to->includes(self)]->first().entity_id]->first();
	
	//Create a readable copy of the arcs
	var arcs := net.arcs;
	
	//Getting the next transition after the task
	var nextTransition := net.nodes[incoming->intersection(resourceOwner.outgoing)->size() <> 0]->first();
	
	//Creating the arcs
	var arc1 := new Arc();
	var arc2 := new Arc();
	
	arc1.net := net;
	arc2.net := net;
	
	arc1.source := result;
	arc2.target := result;
	
	arc1.target := nextTransition;
	arc2.source := nextTransition;
	
	result.outgoing := result.outgoing ->union(arc1->asSet());
	result.incoming := result.incoming ->union(arc2->asSet());
	
	nextTransition.incoming := result.incoming->union(arc1->asSet());
	nextTransition.outgoing := result.outgoing->union(arc2->asSet());
	
	log(net.arcs->size().toString());
	arcs := arcs->union(arc1->asSet())->asOrderedSet();
	arcs += arc2;
	log(net.arcs->size().toString());
	
	
	//populating the resource place
	result.name := "Resource "+self.resource_id;
}

constructor Petrinet::Arc::Arc(net: PetriNet,s: Node, t: Node){
	result.source := s;
	result.target := t;
	result.net := net;
}