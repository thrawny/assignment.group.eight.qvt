modeltype Workflow uses workflowengine('http://workflowengine/1.0');
modeltype Petrinet uses petrinet('chalmers.se/cse/mde2014');

transformation Workflow2Petrinet(in source:Workflow, out target:Petrinet);


main() {
	var globalNet := source.rootObjects()[Workflow::Case]->map case2petriNet();
}

mapping Workflow::Case::case2petriNet() : PetriNet {
	result.name := "GlobalNet";
	
	//Step 1: tasks, startopoint and  endpoint -> places
	result.nodes := self.contains_tasks.map task2place(result)->asOrderedSet()
		->union(self.begins_with.map sp2place(result) -> asOrderedSet())
		->union(self.ends_with.map ep2place(result) -> asOrderedSet());
		
	//Step 2: controller -> transitions
	result.nodes := result.nodes->union(self.contains_controllers.map controller2tran(result)->asOrderedSet());
	
	
	/*
	*
	*Step 3: check for special cases in our model and transform them accordingly in petrinet
	*
	*/
	
	//Creating a writable copy of the transitions
	var transitions := self.contains_transitions;
	
	//Creating a writable copy of nodes
	var places := result.nodes;
	
	//Temporary collection for entities that are not controllers
	var tmp : Set(Element);
	tmp := tmp->union(self.allSubobjectsOfType(StartPoint))
		->union(self.allSubobjectsOfType(Task))
		->union(self.allSubobjectsOfType(EndPoint));
		
	tmp -> forEach(tmp1){
	tmp -> forEach(tmp2){
		//Casting
		var task1 := tmp1.oclAsType(Workflow::Entity);
		var task2 := tmp2.oclAsType(Workflow::Entity);
		
		if(task1 <> task2 ) then {
			//Creating the intersection of transitions
			var commonTrans := task1.outgoing_transitions->intersection(task2.incoming_transitions)->asOrderedSet();
			
			//There's a connection
			if (commonTrans->size() = 1) then{
			
			//Creating the dummy transition between the two places 
			var transition : Petrinet::Transition := new Petrinet::Transition();
			
			//Creating the two places
			var place1 := places[name = task1.entity_id]->first();
			var place2 := places[name = task2.entity_id]->first();
			
			//Creating the connecting Arcs
			var arc1 : Petrinet::Arc := new Petrinet::Arc();
			var arc2 : Petrinet::Arc := new Petrinet::Arc();
			
			//Populating arcs' properties'
			arc1.source := place1;
			arc1.target := transition;
			arc1.net := result;
			arc2.source := transition;
			arc2.target := place2;task1.outgoing_transitions->intersection(task2.incoming_transitions);
			arc2.net := result;
			
			//Populating the transition properties
			transition.name := task1.entity_id+" to "+task2.entity_id;
			transition.net := result;
			
			//Removing the transition already transofrmed
			transitions := (transitions- commonTrans)->asOrderedSet();
			
			//Adding the transition to the petrinet
			result.nodes += transition;
			
			//Adding the arcs to the petrinet
			result.arcs += arc1;
			result.arcs += arc2;

		}endif
		}endif
	}
	};
	
	


	
	
	
	self.contains_controllers -> forEach(cont1){
	self.contains_controllers -> forEach(cont2){
		
		if(cont1 <> cont2) then{
			//Creating the common transitions
			var commonTransitions := cont1.outgoing_transitions->intersection(cont2.incoming_transitions);
			
			//There's a match'
			if(commonTransitions->size() <> 0) then {
			
				//Creating a dummy place between the two controllers
				var place : Petrinet::Place := new Petrinet::Place();
				
				//Creating the arcs to connect them
				var arc1 : Petrinet::Arc := new Petrinet::Arc();
				var arc2 : Petrinet::Arc := new Petrinet::Arc();
				
				//Creating the two transitions
				var tran1 := nodes[name = cont1.entity_id]->first();
				var tran2 := nodes[name = cont2.entity_id]->first();
				
				//Populating the transitions properties
				arc1.source := tran1;
				arc1.target := place;
				arc1.net := result;
				arc2.source := place;
				arc2.target := tran2;
				arc2.net := result;
				
				//Populating the dummy place properties
				place.name := cont1.entity_id+" to "+cont2.entity_id;
				place.net := result;
				
				//Adding the dummyplace to the petrinet
				result.nodes += place;
				
				//Adding the arcs to the petrinet
				result.arcs += arc1;
				result.arcs += arc2;
				
				//Removing the transition already transofrmed
				transitions := (transitions- commonTransitions)->asOrderedSet();
				
			} endif;
		}endif
	}
	};	
		
	/**
	*
	* Adding the remaining arcs
	*
	*/	
	result.arcs := result.arcs->union(transitions.map tran2arc(result, self)->asOrderedSet());
	

}

mapping Task::task2place(in globalNet : PetriNet) : Petrinet::Place {
	result.name := self.entity_id;
	result.net := globalNet;
}

mapping StartPoint::sp2place(in globalNet : PetriNet) : Petrinet::Place {
	result.name := self.entity_id;
	result.net := globalNet;	
}

mapping EndPoint::ep2place(in globalNet : PetriNet) : Petrinet::Place {
	result.name := self.entity_id;
	result.net := globalNet;
}

mapping Controller:: controller2tran(in globalNet : PetriNet) : Petrinet::Transition {
	result.name := self.entity_id;
	result.net := globalNet;
	if self.oclIsKindOf(Selection) 	then {
		result.transition_type := petrinet::Type::Selection;
	} else if self.oclIsKindOf(Synchronization) then {
		result.transition_type := petrinet::Type::Synchronization;
	} else if self.oclIsKindOf(FIFO)  then {
		result.transition_type := petrinet::Type::FIFO;
	} else if self.oclIsKindOf(Iteration) then {
		result.transition_type := petrinet::Type::Iteration;
	} else {
		result.transition_type := petrinet::Type::Fork;
	}
	endif endif endif endif;
}

mapping Workflow::Transition::tran2arc(globalNet: PetriNet, ourCase : Case) : Petrinet::Arc {
	result.net := globalNet;
	var entities := ourCase.allSubobjectsOfKind(Entity)->oclAsType(Entity);
	result.source := globalNet.nodes[name = entities[outgoing_transitions->includes(self)]->asOrderedSet()->first().entity_id]->asOrderedSet()->first();
	result.target := globalNet.nodes[name = entities[incoming_transitions->includes(self)]->asOrderedSet()->first().entity_id]->asOrderedSet()->first();
	log(result.source.toString());
}

/*uery Workflow::Transition::isPartOfASpecialCase() : Boolean {
	
}

helper Case::taskSpecialCases(globalNet : PetriNet) : OrderedSet(Petrinet::Transition) {
	var places := globalNet.nodes;
	var res : OrderedSet(Petrinet::Transition);
	var tmp : Set(Element);
	
	tmp := tmp->union(self.allSubobjectsOfType(StartPoint))
		->union(self.allSubobjectsOfType(Task))
		->union(self.allSubobjectsOfType(EndPoint));
		
	tmp -> forEach(tmp1){
	tmp -> forEach(tmp2){
		var task1 := tmp1.oclAsType(Workflow::Entity);
		var task2 := tmp2.oclAsType(Workflow::Entity);
		
		if(task1 <> task2 
			and task1.outgoing_transitions->intersection(task2.incoming_transitions)
			->size() = 1) then{
			//Transition
			var transition : Petrinet::Transition := new Petrinet::Transition();
			
			//Places
			var place1 := places[name = task1.entity_id]->first();
			var place2 := places[name = task2.entity_id]->first();
			//Arcs
			var arc1 : Petrinet::Arc := new Petrinet::Arc();
			var arc2 : Petrinet::Arc := new Petrinet::Arc();
			
			arc1.source := place1;
			arc1.target := transition;
			arc1.net := globalNet;
			arc2.source := transition;
			arc2.target := place2;
			arc2.net := globalNet;
			

			globalNet.arcs->union(arc1->asOrderedSet());
			globalNet.arcs->append(arc2);

			

			transition.name := task1.entity_id+" to "+task2.entity_id;
			transition.net := globalNet;
			res += transition;
		}endif
	}
	};	
	return res;
}

helper Case::controllerSpecialCases(in globalNet : PetriNet) : OrderedSet(Petrinet::Place) {
	var res : OrderedSet(Petrinet::Place);
	var tmp : Set(Workflow::Controller);
	var nodes := globalNet.nodes;
	
	tmp := self.contains_controllers;
	
	tmp -> forEach(cont1){
	tmp -> forEach(cont2){
		if(cont1 <> cont2 
			and cont1.outgoing_transitions->intersection(cont2.incoming_transitions)
			->size() = 1) then{
			//Place
			var place : Petrinet::Place := new Petrinet::Place();
			
			//Arcs
			var arc1 : Petrinet::Arc := new Petrinet::Arc();
			var arc2 : Petrinet::Arc := new Petrinet::Arc();
			
			//Transitions
			var tran1 := nodes[name = cont1.entity_id]->first();
			var tran2 := nodes[name = cont2.entity_id]->first();
			
			arc1.source := tran1;
			arc1.target := place;
			arc1.net := globalNet;
			arc2.source := place;
			arc2.target := tran2;
			arc2.net := globalNet;
			place.name := cont1.entity_id+" to "+cont2.entity_id;
			place.net := globalNet;
			res += place;
		}endif
	}
	};	
	return res;
}*/

/*helper Case::createArcs(in globalNet : PetriNet ) : OrderedSet(Petrinet::Arc) {
	var res : OrderedSet(Petrinet::Arc);
	var nodes := globalNet.nodes;
	var entities := self.allSubobjectsOfKind(Entity);
	
	entities-> forEach(ent1){
	entities-> forEach(ent2){
		if(ent1)
		
	}
	}
	
	
	res->union(self.contains_transitions.map tran2arc(globalNet)->asOrderedSet());
	return res;
}
*/
























/*


mapping Workflow::Case::transition2arc(in entities: Set(Entity), globalNet : PetriNet) : OrderedSet(Petrinet::Arc) {
	entities -> forEach(en1){
		entities -> forEach(en2){
			if en1 <> en2 then{
				en1.outgoing_transitions -> forEach(tran1){
					en2.incoming_transitions -> forEach(tran2){
						if tran1 = tran2
						then {
							var tmpArc :  Arc := new Arc();
							tmpArc.net := globalNet;
							if en1.oclIsKindOf(Controller) 	then {
								tmpArc.source := en1.oclAsType(Controller).map controller2tran(globalNet);
							} else if en1.oclIsKindOf(Task) then {
								tmpArc.source := en1.oclAsType(Task).map task2place(globalNet);
							} else if en1.oclIsKindOf(StartPoint)  then {
								tmpArc.source := en1.oclAsType(StartPoint).map sp2place(globalNet);
							} else {
								tmpArc.source := en1.oclAsType(EndPoint).map ep2place(globalNet);
							}
							endif endif endif;
							
							if en2.oclIsKindOf(Controller) 	then {
								tmpArc.target := en2.oclAsType(Controller).map controller2tran(globalNet);
							} else if en2.oclIsKindOf(Task) then {
								tmpArc.target := en2.oclAsType(Task).map task2place(globalNet);
							} else if en2.oclIsKindOf(StartPoint)  then {
								tmpArc.target := en2.oclAsType(StartPoint).map sp2place(globalNet);
							} else {
								tmpArc.target := en2.oclAsType(EndPoint).map ep2place(globalNet);
							}
							endif endif endif;
							log("Source: "+en1.entity_id+" Target: "+en2.entity_id)
						}
						endif
					}
				}
			} endif
		}
	
	}
}










*/
