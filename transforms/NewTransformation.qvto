modeltype Workflow uses workflowengine('http://workflowengine/1.0');
modeltype Petrinet uses petrinet('chalmers.se/cse/mde2014');

transformation Workflow2Petrinet(in source:Workflow, out target:Petrinet);


main() {
	var globalNet := source.rootObjects()[Workflow::Case]->map case2petriNet();
}

mapping Workflow::Case::case2petriNet() : PetriNet {
	result.name := "GlobalNet";
	
	/*
	*
	*Step 1: mapping startPoint, endPoint and tasks to places
	*
	*/
	result.nodes := self.contains_tasks.map task2place(result)->asOrderedSet()
		->union(self.begins_with.map sp2place(result) -> asOrderedSet())
		->union(self.ends_with.map ep2place(result) -> asOrderedSet());
		
	/*
	*
	*Step 2: mapping controllers to transitions
	*
	*/
	result.nodes := result.nodes->union(self.contains_controllers.map controller2tran(result)->asOrderedSet());
	
	
	/*
	*
	*Step 3: check for special cases in our model and transform them accordingly in petrinet
	*
	*/
	
	//Creating a writable copy of the transitions
	var transitions := self.contains_transitions;
	
	//Creating a writable copy of nodes
	var places := result.nodes;
	
	//Temporary collection for entities that are not controllers
	var tmp : Set(Element);
	
	//Searching for special cases on tasks
	tmp := tmp->union(self.allSubobjectsOfType(StartPoint))
		->union(self.allSubobjectsOfType(Task))
		->union(self.allSubobjectsOfType(EndPoint));
		
	tmp -> forEach(tmp1){
	tmp -> forEach(tmp2){
		//Casting
		var task1 := tmp1.oclAsType(Workflow::Entity);
		var task2 := tmp2.oclAsType(Workflow::Entity);
		
		if(task1 <> task2 ) then {
			//Creating the intersection of transitions
			var commonTrans := task1.outgoing_transitions->intersection(task2.incoming_transitions)->asOrderedSet();
			
			//There's a connection
			if (commonTrans->size() = 1) then{
			
			//Creating the dummy transition between the two places 
			var transition : Petrinet::Transition := new Petrinet::Transition();
			
			//Creating the two places
			var place1 := places[name = task1.entity_id]->first();
			var place2 := places[name = task2.entity_id]->first();
			
			//Creating the connecting Arcs
			var arc1 : Petrinet::Arc := new Petrinet::Arc();
			var arc2 : Petrinet::Arc := new Petrinet::Arc();
			
			//Populating arcs' properties'
			arc1.source := place1;
			arc1.target := transition;
			arc1.net := result;
			arc2.source := transition;
			arc2.target := place2;task1.outgoing_transitions->intersection(task2.incoming_transitions);
			arc2.net := result;
			
			//Populating the transition properties
			transition.name := task1.entity_id+" to "+task2.entity_id;
			transition.net := result;
			transition.incoming := arc1->asSet();
			transition.outgoing := arc2->asSet();
			
			//Removing the transition already transofrmed
			transitions := (transitions- commonTrans)->asOrderedSet();
			
			//Adding the transition to the petrinet
			result.nodes += transition;
			
			//Adding the arcs to the petrinet
			result.arcs += arc1;
			result.arcs += arc2;
			
			//Addng incoming and outgoing arcs to the places
			place1.outgoing := place1.outgoing->union(arc1->asSet());
			place2.incoming := place2.incoming->union(arc2->asSet());

		}endif
		}endif
	}
	};
	
	


	
	
	//Searching for special cases on controllers
	self.contains_controllers -> forEach(cont1){
	self.contains_controllers -> forEach(cont2){
		
		if(cont1 <> cont2) then{
			//Creating the common transitions
			var commonTransitions := cont1.outgoing_transitions->intersection(cont2.incoming_transitions);
			
			//There's a match'
			if(commonTransitions->size() <> 0) then {
			
				//Creating a dummy place between the two controllers
				var place : Petrinet::Place := new Petrinet::Place();
				
				//Creating the arcs to connect them
				var arc1 : Petrinet::Arc := new Petrinet::Arc();
				var arc2 : Petrinet::Arc := new Petrinet::Arc();
				
				//Creating the two transitions
				var tran1 := nodes[name = cont1.entity_id]->first();
				var tran2 := nodes[name = cont2.entity_id]->first();
				
				//Populating the transitions properties
				arc1.source := tran1;
				arc1.target := place;
				arc1.net := result;
				arc2.source := place;
				arc2.target := tran2;
				arc2.net := result;
				
				//Populating the dummy place properties
				place.name := cont1.entity_id+" to "+cont2.entity_id;
				place.net := result;
				place.incoming := arc1->asSet();
				place.outgoing := arc2->asSet();
				
				//Adding the dummyplace to the petrinet
				result.nodes += place;
				
				//Adding the arcs to the petrinet
				result.arcs += arc1;
				result.arcs += arc2;
				
				//Removing the transition already transofrmed
				transitions := (transitions- commonTransitions)->asOrderedSet();
				
				//Addng incoming and outgoing arcs to the places
				tran1.outgoing := tran1.outgoing->union(arc1->asSet());
				tran2.incoming := tran2.incoming->union(arc2->asSet());
				
				
			} endif;
		}endif
	}
	};	
		
	/**
	*
	* Step 4: Adding the remaining arcs
	*
	*/	
	result.arcs := result.arcs->union(transitions.map tran2arc(result, self)->asOrderedSet());
	

}

mapping Task::task2place(in globalNet : PetriNet) : Petrinet::Place {
	result.name := self.entity_id;
	result.net := globalNet;
}

mapping StartPoint::sp2place(in globalNet : PetriNet) : Petrinet::Place {
	result.name := self.entity_id;
	result.net := globalNet;	
}

mapping EndPoint::ep2place(in globalNet : PetriNet) : Petrinet::Place {
	result.name := self.entity_id;
	result.net := globalNet;
}

mapping Controller:: controller2tran(in globalNet : PetriNet) : Petrinet::Transition {
	result.name := self.entity_id;
	result.net := globalNet;
	if self.oclIsKindOf(Selection) 	then {
		result.transition_type := petrinet::Type::Selection;
	} else if self.oclIsKindOf(Synchronization) then {
		result.transition_type := petrinet::Type::Synchronization;
	} else if self.oclIsKindOf(FIFO)  then {
		result.transition_type := petrinet::Type::FIFO;
	} else if self.oclIsKindOf(Iteration) then {
		result.transition_type := petrinet::Type::Iteration;
	} else {
		result.transition_type := petrinet::Type::Fork;
	}
	endif endif endif endif;
}

mapping Workflow::Transition::tran2arc(globalNet: PetriNet, ourCase : Case) : Petrinet::Arc {
	//Casting
	var entities := ourCase.allSubobjectsOfKind(Entity)->oclAsType(Entity);
	
	//Getting source and target nodes
	var sourceNode := globalNet.nodes[name = entities[outgoing_transitions->includes(self)]->asOrderedSet()->first().entity_id]->asOrderedSet()->first();
	var targetNode := globalNet.nodes[name = entities[incoming_transitions->includes(self)]->asOrderedSet()->first().entity_id]->asOrderedSet()->first();
	
	//Populating the properties of the arc
	result.net := globalNet;
	result.source := sourceNode;
	result.target := targetNode;
	
	//Adding the arc as outgoing and incoming for sourceNode and targetNode respectively
	sourceNode.outgoing := sourceNode.outgoing->union(result->asSet());
	targetNode.incoming := targetNode.incoming->union(result->asSet());
	

}